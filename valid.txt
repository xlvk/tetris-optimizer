var BOARD [][]string

// All possible Tetris figures variations
var FIGURES [][][]string = [][][]string{
	{{"#", "#", "#"}, {".", "#", "."}},
	{{"#", "."}, {"#", "#"}, {"#", "."}},
	{{".", "#", "."}, {"#", "#", "#"}},
	{{"#", "."}, {"#", "#"}, {".", "#"}},
	{{"#", "#"}, {"#", "#"}},
	{{"#"}, {"#"}, {"#"}, {"#"}},
	{{"#", "#", "#", "#"}},
	{{"#", "#", "."}, {".", "#", "#"}},
	{{".", "#"}, {"#", "#"}, {"#", "."}},
	{{"#", "#", "."}, {".", "#", "#"}},
	{{".", "#"}, {"#", "#"}, {"#", "."}},
	{{"#", "."}, {"#", "."}, {"#", "#"}},
	{{"#", "#", "#"}, {".", ".", "#"}},
	{{"#", "#"}, {".", "#"}, {".", "#"}},
	{{"#", "."}, {"#", "#"}, {"#", "#"}},
	{{"#", "#"}, {"#", "#"}, {"#", "."}},
	{{".", ".", "#"}, {"#", "#", "#"}},
	{{"#", "#"}, {"#", "."}, {"#", "."}},
	{{"#", "#", "#"}, {"#", ".", "."}},
}

type Tetrominoes struct {
	form [][]string
}

// Checks file format
func CheckFormat(transformedContent [][]string) {
	index := 0

	for i := 0; i < len(transformedContent); i++ {
		if len(transformedContent[i]) == 0 {
			if index != 4 {
				fmt.Println("Error. Bad format or figure doesn't consist of 4 cubes.")
				os.Exit(1)
			} else {
				index = 0
			}
		}
		for k := 0; k < len(transformedContent[i]); k++ {
			if transformedContent[i][k] == "#" {
				index++
			}
		}
	}
}

// Finds all tetrominoes from the file
func FindTetrominoes(transformedContent [][]string) []Tetrominoes {
	var tetrominoToAppend Tetrominoes
	var tetrominoesList []Tetrominoes
	tetrisCounter := 1

	for a := 0; a < len(transformedContent); a++ {
		for b := 0; b < len(transformedContent[a]); b++ {
			var found bool = false
			for i := 0; i < len(FIGURES); i++ {
				var skip bool = false
				for k := 0; k < len(FIGURES[i]); k++ {
					for m := 0; m < len(FIGURES[i][k]); m++ {
						if a+k == tetrisCounter*5-1 || b+m >= 4 {
							skip = true
							break
						}
						if transformedContent[a+k][b+m] == FIGURES[i][k][m] {
							continue
						}
						skip = true
						break
					}
					if skip {
						break
					}
				}
				if !skip {
					found = true
					tetrominoToAppend.form = FIGURES[i]
					tetrominoesList = append(tetrominoesList, tetrominoToAppend)
					break
				}
			}
			if found {
				if a+(tetrisCounter*5-a) >= len(transformedContent) {
					a = len(transformedContent) - 1
				} else {
					a = a + (tetrisCounter*5 - a) - 1
				}
				tetrisCounter++
				break
			}

			if a == (tetrisCounter*5)-2 && b == 3 {
				fmt.Println("Error. Unknown tetromino.")
				os.Exit(2)
			}
		}
	}

	return tetrominoesList
}

// Calculates minimum possible board size
func FindBoardMinSize(tetrominoesList []Tetrominoes) int {
	minSideSize := 0
	for i := 0; i < len(tetrominoesList); i++ {
		for k := 0; k < len(tetrominoesList[i].form); k++ {
			if minSideSize < len(tetrominoesList[i].form[k]) {
				minSideSize = len(tetrominoesList[i].form[k])
			}

			if minSideSize < len(tetrominoesList[i].form) {
				minSideSize = len(tetrominoesList[i].form)
			}

			if minSideSize == 4 {
				break
			}
		}
	}

	blockCounter := math.Sqrt(float64(len(tetrominoesList) * 4))
	_, frac := math.Modf(blockCounter)
	if frac != 0 {
		blockCounter = math.Floor(blockCounter) + 1
	}

	return int(math.Max(blockCounter, float64(minSideSize)))
}

// Finds all tetrominoes from the file
func CreateBoard(size int) {
	BOARD = nil

	for i := 0; i < size; i++ {
		BOARD = append(BOARD, nil)
		for k := 0; k < size; k++ {
			BOARD[i] = append(BOARD[i], ".")
		}
	}
}

// Position selection start
func TryPosition(piece int, tetrominoesList []Tetrominoes, size int) {
	for y := 0; y < len(BOARD); y++ {
		for x := 0; x < len(BOARD); x++ {
			if CheckPosition(y, x, piece, tetrominoesList) {
				if y == len(BOARD)-1 || piece == len(tetrominoesList)-1 {
					PrintBoard()
					os.Exit(0)
				} else {
					TryPosition(piece+1, tetrominoesList, size)
				}
				ClearPosition(y, x, piece, tetrominoesList)
			}
		}
	}

	if piece == 0 {
		increaseSize := size + 1
		CreateBoard(increaseSize)
		TryPosition(0, tetrominoesList, increaseSize)
	}
}

// Checks if applicable position is free
func CheckPosition(y int, x int, piece int, tetrominoesList []Tetrominoes) bool {
	for i := 0; i < len(tetrominoesList[piece].form); i++ {
		if len(tetrominoesList[piece].form)+y > len(BOARD) || len(tetrominoesList[piece].form[i])+x > len(BOARD) {
			return false
		}
	}

	for a := y; a < (len(tetrominoesList[piece].form) + y); a++ {
		for b := x; b < (len(tetrominoesList[piece].form[a-y]) + x); b++ {
			if tetrominoesList[piece].form[a-y][b-x] == "." {
				continue
			}

			if BOARD[a][b] == "." {
				BOARD[a][b] = string(65 + piece)
			} else {
				ClearPosition(y, x, piece, tetrominoesList)
				return false
			}
		}
	}

	return true
}

// Clears certain position after apply
func ClearPosition(y int, x int, piece int, tetrominoesList []Tetrominoes) {
	for a := y; a < (len(tetrominoesList[piece].form) + y); a++ {
		for b := x; b < (len(tetrominoesList[piece].form[a-y]) + x); b++ {
			if tetrominoesList[piece].form[a-y][b-x] == "." {
				continue
			}
			if BOARD[a][b] == string(65+piece) {
				BOARD[a][b] = "."
			}
		}
	}
}

// Print final board
func PrintBoard() {
	for _, row := range BOARD {
		fmt.Println(strings.Join(row, ""))
	}
}

func main() {
	// Read input from file
	content, err := ioutil.ReadFile("input.txt")
	if err != nil {
		fmt.Println("Error reading file:", err)
		os.Exit(1)
	}

	// Process input content
	lines := strings.Split(string(content), "\n")
	var transformedContent [][]string
	for _, line := range lines {
		transformedContent = append(transformedContent, strings.Split(line, ""))
	}

	// Check the format of the input
	CheckFormat(transformedContent)

	// Find the tetrominoes from the input
	tetrominoesList := FindTetrominoes(transformedContent)

	// Calculate the minimum board size
	size := FindBoardMinSize(tetrominoesList)

	// Create the board
	CreateBoard(size)

	// Try different positions to solve the puzzle
	TryPosition(0, tetrominoesList, size)

	fmt.Println("No solution found.")
}





package main

import (
	"log"
)

func Convert(arr []string) []string {
	var result, check []string
	line := ""
	for o := 0; o < len(arr); o++ {
		if arr[o] == "" {
			result = append(result, line)
		} else {
			line += arr[o]
		}
	}
	start := 0
	end := 0
	readFile, err := os.Open("valid.txt")
	defer readFile.Close()
	if err != nil {
		log.Fatalf("failed to open file: %s", err)
	}
	yrs := ""
	fileScanner := bufio.NewScanner(readFile)
	fileScanner.Split(bufio.ScanLines)
	for fileScanner.Scan() {
		if fileScanner.Text() != "" {
			yrs += fileScanner.Text()
		} else {
			result = append(result, yrs)
		}
	}
	checkHere := false
	for i := 0; i < len(check); i++ {
		word := check[o]
		for j := 0; j < len(word); j++ {
			for k := 0; k < len(result); k++ {

			}
		}
	}
}
